# 🧩 Search Algorithms Collection

Այս ֆայլում ներկայացված են մի շարք որոնման ալգորիթմներ՝ Linear Search, Binary Search, Ternary Search և Jump Search։  
Յուրաքանչյուր ալգորիթմի համար տրված են՝ ներածություն, աշխատանքի եղանակը, օրինակ, բարդությունը, առավելություններ և թերություններ։

---

## 1️⃣ Linear Search Algorithm

### 🔹 Ներածություն
**Linear Search**-ը ամենապարզ որոնման ալգորիթմն է։  
Այն աշխատում է հետևյալ կերպ՝ հերթով անցնում է տվյալների հավաքածուի բոլոր տարրերի վրայով և համեմատում տարրը որոնվող արժեքի հետ։

---

### ⚙️ Ինչպես է այն աշխատում
1. Սկսում ենք հավաքածուի առաջին տարրից։  
2. Յուրաքանչյուր տարր համեմատում ենք որոնվող արժեքի հետ։  
3. Եթե տարրը համընկնում է, վերադարձնում ենք True (գտնվել է)։  
4. Եթե հասնում ենք վերջնագծին առանց հաջողության, վերադարձնում ենք False։

---

### ⏱️ Բարդությունը

| Տեսակ | Ժամանակային բարդություն |
|--------|---------------------|
| **Լավագույն դեպք** | O(1) |
| **Միջին դեպք** | O(n) |
| **Վատագույն դեպք** | O(n) |
| **Հիշողության բարդություն** | O(1) |

---

### ⚖️ Առավելություններ և Թերություններ

| 💪 Առավելություններ | ⚠️ Թերություններ |
|---------------------|-----------------|
| Պարզ և արագ իրագործման համար փոքր հավաքածուների վրա | Դանդաղ է մեծ հավաքածուների համար |
| Ոչ մի նախապատրաստում չի պահանջում | Միայն հաջորդական որոնում է՝ O(n) |

---

## 2️⃣ Binary Search Algorithm

### 🔹 Ներածություն
**Binary Search**-ը արագ որոնման ալգորիթմ է դասավորված հավաքածուների համար։  
Այն օգտագործում է "միջին տարրի համեմատում" և բաժանում կեսով՝ գրեթե կեսը բացառելու հնարավորություն։

---

### ⚙️ Ինչպես է այն աշխատում
1. Սկսում ենք դասավորված հավաքածուի սկզբից և վերջից։  
2. Հաշվում ենք միջին տարրը (`mid`)։  
3. Եթե միջին տարրը համընկնում է որոնվող արժեքի հետ, վերադարձնում ենք True։  
4. Եթե միջին տարրը մեծ է որոնվողից, որոնումը շարունակվում է ձախ կեսում, հակառակ դեպքում՝ աջ կեսում։  
5. Կրկնում ենք քայլերը մինչև գտնել տարրը կամ բացառել ամբողջ հավաքածուն։

---

### ⏱️ Բարդությունը

| Տեսակ | Ժամանակային բարդություն |
|--------|---------------------|
| **Լավագույն դեպք** | O(1) |
| **Միջին դեպք** | O(log n) |
| **Վատագույն դեպք** | O(log n) |
| **Հիշողության բարդություն** | O(1) |

---

### ⚖️ Առավելություններ և Թերություններ

| 💪 Առավելություններ | ⚠️ Թերություններ |
|---------------------|-----------------|
| Շատ արագ մեծ հավաքածուների վրա | Աշխատում է միայն դասավորված տվյալների վրա |
| O(log n) բարդություն | Հաճախ պահանջում է նախօրոք դասավորում |

---

## 3️⃣ Ternary Search Algorithm

### 🔹 Ներածություն
**Ternary Search**-ը մոտ Binary Search-ի, բայց բաժանում է հավաքածուն **երեք մասի**՝ երկու միջնորդական կետերով (mid1 և mid2)։

---

### ⚙️ Ինչպես է այն աշխատում
1. Սկսում ենք ամբողջ հավաքածուից, հաշվում mid1 և mid2 կետերը։  
2. Համեմատում ենք mid1 և mid2 արժեքները որոնվողի հետ։  
3. Եթե որոնվողը փոքր է mid1-ից, որոնումը շարունակվում է ձախ մասում։  
4. Եթե մեծ է mid2-ից, որոնումը գնում է աջ մասում։  
5. Հակառակ դեպքում, որոնումը կատարվում է միջին հատվածում։  
6. Կրկնում ենք մինչև գտնել արժեքը կամ ամբողջ հավաքածուն բացառել։

---

### ⏱️ Բարդությունը

| Տեսակ | Ժամանակային բարդություն |
|--------|---------------------|
| **Լավագույն դեպք** | O(1) |
| **Միջին դեպք** | O(log₃ n) |
| **Վատագույն դեպք** | O(log₃ n) |
| **Հիշողության բարդություն** | O(1) |

---

### ⚖️ Առավելություններ և Թերություններ

| 💪 Առավելություններ | ⚠️ Թերություններ |
|---------------------|-----------------|
| Կարող է քիչ անգամ դիտարկել տարրերը Binary Search-ի փոխարեն | Պետք է դասավորված հավաքածու |
| Օգտակար է մեծ տվյալների համար՝ log₃ n բարդությամբ | Սովորաբար օգտագործվում է հազվադեպ |

---

## 4️⃣ Jump Search Algorithm

### 🔹 Ներածություն
**Jump Search**-ը դասավորված հավաքածուների որոնման ալգորիթմ է, որը անցնում է քայլերով (step), օրինակ √n տարրերով, ապա կատարում է ընթացիկ հատվածում linearly search։

---

### ⚙️ Ինչպես է այն աշխատում
1. Նախահաշվել քայլի չափը՝ step = √n։  
2. Աջ թռիչքներով անցնել հավաքածուում մինչև գտնել հատված, որտեղ կարող է լինել որոնվող տարրը։  
3. Մուտք գործել այդ հատվածի linearly որոնումը։  
4. Վերադարձնել True, եթե գտնում ենք, հակառակ դեպքում՝ False։

---

### ⏱️ Բարդությունը

| Տեսակ | Ժամանակային բարդություն |
|--------|---------------------|
| **Լավագույն դեպք** | O(1) |
| **Միջին դեպք** | O(√n) |
| **Վատագույն դեպք** | O(√n) |
| **Հիշողության բարդություն** | O(1) |

---

### ⚖️ Առավելություններ և Թերություններ

| 💪 Առավելություններ | ⚠️ Թերություններ |
|---------------------|-----------------|
| Ավելի արագ է, քան Linear Search դասավորված հավաքածուների համար | Պետք է դասավորված տվյալներ |
| O(√n) միջին բարդություն | Պետք է չափել ճիշտ step-ը |
| Միաժամանակ linearly և block-search | |

---

## 💡 Ամփոփում

Այստեղ ներկայացված են 4 հիմնական որոնման ալգորիթմներ՝ Linear, Binary, Ternary և Jump Search։  
Յուրաքանչյուրն ունի տարբեր կիրառություններ՝ կախված տվյալների չափից, դասավորվածությունից և արդյունավետության պահանջից։

- **Linear Search** – պարզ, փոքր հավաքածուների համար  
- **Binary Search** – դասավորված մեծ հավաքածուների արագ որոնում  
- **Ternary Search** – բարդությունը log₃ n, կարող է ավելի արդյունավետ լինել որոշ դեպքերում  
- **Jump Search** – միջին բարդություն √n, օգտագործվում է դասավորված տվյալների համար  

---

